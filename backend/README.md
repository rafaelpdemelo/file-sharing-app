# Deploy using Minikube

Inside the frontend/ folder and here, you will find several .yaml files. These are responsible for orchestrating and managing the deployment of your application to a Kubernetes cluster, generated by minikube.

The Deployment files (backend-deployment.yaml / frontend-deployment.yaml) define the specifications for creating Pods and ReplicaSets for the backend and frontend of your application, respectively. A Pod is the smallest unit of compute that can be deployed and managed in Kubernetes, while a ReplicaSet ensures that a specific number of pod replicas are running at any given time.

Service files (backend-service.yaml / frontend-service.yaml) are used to expose your deployments as services within the cluster. A service in Kubernetes is an abstraction that defines a logical set of Pods and a policy by which to access them.

The Ingress file (ingress.yaml) is used to manage external access to services in a cluster, typically HTTP. Ingress can provide load balancing, SSL termination, and name-based virtual hosting.

These files ensure that your application is ready to receive internet traffic as soon as it is exposed by Ingress.


## Deploy

To deploy this project we will need ```minikube kubectl and docker```


1 - Start minikube

```bash
  minikube start
```

2 - Now we will need to map your IP from minikube to create a host and point your IP to it:

```bash
    minikube ip
```

3 - Open your /etc/hosts file and add a new line to point your minikube ip stream to your chosen host,
you may see something like this:

```bash
# Loopback entries; do not change.
# For historical reasons, localhost precedes localhost.localdomain:
127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4
::1 localhost localhost.localdomain localhost6 localhost6.localdomain6
# See hosts(5) for proper format and other examples:
# 192.168.1.10 foo.mydomain.org foo
# 192.168.1.13 bar.mydomain.org bar

```

Just add:

```bash
 your minikube ip yourhost.com
 192.168.49.2 filesharingapp.com <- This is my case

 ps: your host can be any name. mine is called filesharginapp.com
```
It looks like this


```bash
# Loopback entries; do not change.
# For historical reasons, localhost precedes localhost.localdomain:
127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4
::1 localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.49.2 filesharingapp.com
# See hosts(5) for proper format and other examples:
# 192.168.1.10 foo.mydomain.org foo
# 192.168.1.13 bar.mydomain.org bar
```

Great! Let's continue.

Now that you have your host mapped to your minikube ip, let's build and upload an image to the docke hub, this will be necessary for our deployment .yaml files to fetch an image from our React and Node project.

Let's set up our project to receive traffic from the host you have now registered. 

4 - Go to: ```backend/src/index.js``` and let's change our CORS source domains:


```javascript
// Cors to identify the origin of the uploaded files, in this case it is the React Application.
app.use(cors({
  origin: ['http://localhost:3000', 'http://localhost', 'http://localhost:80', 'http://127.0.0.1:30080', 'http://NOMEDOSEUHOST.com:30080'] // Test this endpoints for minikube... But my firewall is not allowing minikube to work 
}));
```

4 - Still in the file ```backend/src/index.js``` we go in the POST route and we will change the end of it, where it has a link:

```bash
app.post('/upload/:name', upload.single('file'), (req, res) => {
  // check if file was actually received
  if (!req.file) {
    res.status(400);
    return res.json({ error: 'No file received' });
  }
  
  const filePath = path.join(uploadsDir, req.params.name);
  // Check if file exists before upload
  if (fs.existsSync(filePath)) {
    console.warn('File already exists and will be replaced');
    return res.status(409).json({
      success: false, 
      message: 'File already exists and will be replaced',
    });
  }

  // Store the password associated with this file
  const password = req.body.password;
  const hashedPassword = bcrypt.hashSync(password, 10);
  filePasswords[req.params.name] = hashedPassword;
  
  // If file doesn't exist, proceed with upload
  fs.renameSync(req.file.path, filePath);
  console.warn('File uploaded successfully');
  return res.json({ 
    success: true, 
    message: 'File uploaded successfully',
    downloadUrl: `http://NOMEDOSEUHOST.COM:30001/download/${req.params.name}` <- Change Port too!
  });
});

```

5 - Now go to the file ``` frontend/src/App.js ``` and change the functions ```handleUpload``` and ```handleDownload```.

```bash

  const handleUpload = async () => {
    try {
      const formData = new FormData();
      formData.append('file', fileInputRef.current.files[0]);
      formData.append('password', passwordRef.current.value);
  
      const res = await axios.post(
        `http://NAMEOFYOURHOST.COM:30001/upload/${fileInputRef.current.files[0].name}`, <- Change Port too!
        formData
      );
      
      if (res.status === 200) {
        alert(`File uploaded successfully. Download URL: ${res.data.downloadUrl}`);
        
        passwordRef.current.value = "";
        fileInputRef.current.value = null;
      }
    } catch (error) {
      if (error.response && error.response.status === 409) {
        alert(`${error.response.data.message}`);
      } else if (error.response && error.response.status === 403) {
        alert(`${error.response.data.message}`); 
      }else {
        alert(`Failed to upload file: ${error}`);
      }
    }
  };

  const handleDownload = async () => {
    try {
      const filename = prompt('Enter filename to download:');
      const res = await axios.get(
        `http://NAMEOFYOURHOST.COM:30001/download/${filename}`, <- Change Port too!
        {
          headers: {
            password: passwordRef.current.value
          },
        }
      );
      
      const url = window.URL.createObjectURL(new Blob([res.data]));
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', filename);
      document.body.appendChild(link);
      link.click();
    } catch (error) {
      console.log(error.response)
      if (error.response && error.response.status === 403) {
        alert('Incorrect Password or File Name');
      } else {
        alert(`Failed to download file: ${error.message}`);
      }
    }
};

```

6 - Great! Now let's build these 2 applications using docker.

- Let's go to the ```backend/``` folder and run the command:

PS: remember to change your user in the command below to the dockerhub user.

```
docker build -t [username]/node-app:latest -f node.Dockerfile .
```

7 - Go to the ```frontend/``` folder and run the command:

```
docker build -t [username]/react-app:latest -f react.Dockerfile .
```

8 - Great! We already have our local image ready, now we just need to send it to a repository on dockerhub

Run the command to point out that the image we will upload to the repository should mirror your local image:

```
docker tag [username]/node-app:latest [username]/node-app:latest
docker tag [username]/react-app:latest [username]/react-app:latest

docker push [username]/node-app:latest
docker push [username]/react-app:latest
```

PS: Remember to change your user in the above command to the dockerhub user.

9 - Now let's change the .yaml files to update the images.

Go to the ```backend/``` folder and open the ```backend-deployment.yaml``` file.

```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      component: backend
  template:
    metadata:
      labels:
        component: backend
    spec:
      containers:
      - name: backend
        image: [username]/node-app:latest       <---- Update this part here
        ports:
        - containerPort: 3001

```

Now let's open ```ingress.yaml```

Let's change the following here:

```
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-ingress
spec:
  rules:
  - host: "filesharingapp.com" <------- This part here. Put your host, the same as you used in step 3
    http:
      paths:
      - pathType: Prefix
        path: "/upload/"
        backend:
          service:
            name: backend-service
            port:
              number: 3001
      - pathType: Prefix
        path: "/download/"
        backend:
          service:
            name: backend-service
            port:
              number: 3001

```

Now let's do the same for the deployment file that is in ```frontend/```

```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: [username]/react-app:latest   <---- Update this part here
        ports:
        - containerPort: 80
```

Everything looks ok! 

10 - Now let's apply the deployment, service and ingress files using kubectl.

Go to the ```backend/``` folder and run the following commands:

```
kubectl apply -f backend-deployment.yaml
kubectl apply -f backend-service.yaml
kubectl apply -f ingress.yaml
```

Go to the ```frontend/``` folder and run the following commands:

```
kubectl apply -f frontend-deployment.yaml
kubectl apply -f frontend-service.yaml
```

11 - Now you can run the command ```minikube addons enable ingress``` to enable the Ingress addon on your Minikube cluster.

12 - Now open the minikube dashboard with ```minikube dashboard```. 

13 - You can see that the services are up and running correctly, if not, review the step by step to check for any problems.

14 - Now if you access ```http://SEUHOSTNAME.COM/30080``` you can see your application running.
